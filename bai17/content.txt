1. Functions
1.1 Kiến thức tổng quan
    - Hàm là 1 chương trình con giúp thực thi một công việc cụ thể
    - Có 2 loại hàm:
        + Hàm built-in (Hàm có sẵn trong javascript): console.log(), alert(), prompt(),...
        + Hàm tự định nghĩa: Là hàm do chúng ta tự viết ra. VD như hàm tính toán cộng, trừ, nhân, chia
    - Cú pháp hàm tự định nghĩa:
        function tenHam(thamSo1, thamSo2,...) {
            //Code
        }
    - Gọi hàm:
    tenHam(doiSo1, doiSo2,...);
    - Đối tượng arguments: chỉ dùng được ở trong hàm. Giả sử khi gọi hàm và truyền đối số vào thì tất cả các đối số đó
sẽ được nằm trong arguments dưới dạng một mảng
    - Từ khoá return: sẽ trả về kết quả nằm ở bên phải của chữ return. Những dòng code ở bên dưới return sẽ không hoạt động
    - Lưu ý:
        + Nếu đặt trùng tên hàm khi ta gọi hàm thì việc gọi hàm này sẽ chạy vào hàm cuối cùng
        + Nếu một biến được định nghĩa ở trong function thì biến đó chỉ sử dụng được ở trong function đó thôi (Kể cả biến var).
    Nhưng khai báo biến var trong if else thì bên ngoài vẫn dùng được
        + Nếu hàm A nằm trong hàm B thì hàm A chỉ gọi được ở trong hàm B thôi, không gọi được ở bên ngoài hàm B 
1.2 Các loại hàm (các cách viết hàm)
1.2.1 Declaration function (Hàm định nghĩa)
    - Có tính hoisting (tức là gọi được hàm trước khi khai báo hàm đó)
    - Cú pháp:
        function tenHam(thamSo1, thamSo2,...) {
            //Code
        }
1.2.2 Expression function (Hàm biểu thức)
    - Không có tính hoisting (Nếu gọi hàm trước lúc khai báo hàm thì sẽ gặp lỗi)
    - Cú pháp:
        var tenHam = function(thamSo1, thamSo2,...) {
            //Code
        }
1.2.3 Arrow function (Hàm mũi tên)
    - Không có tính hoisting (Nếu gọi hàm trước lúc khai báo hàm thì sẽ gặp lỗi)
    - Cú pháp:
        var tenHam = (thamSo1, thamSo2,...) => {
            //Code
        }
    - Lưu ý: Arrow Functions sẽ không có arguments. Để lấy các đối số đã truyền dưới dạng một mảng thì chúng ta sẽ sử dụng cú pháp spread
1.3 Ví dụ về hàm
    - VD1: Tính tổng các số chẵn của mảng. Mảng như sau:
        var mang = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
    - VD2: Viết chương trình cho người dùng nhập vào số n lớn hơn 0, sau đó dựa vào n tính giá trị của biểu thức:
        bieuThuc = 1/n + 2/n + 3/n + ... + n/n
2. Try Catch
    - Là một khối lệnh dùng để bắt lỗi chương trình
    - Ta sử dụng try catch khi muốn chương trình không bị dừng khi một lệnh nào đó bị lỗi. Thường thì đó là những lỗi do người dùng nhập sai dữ liệu
    hoặc người dùng thao tác bị sai
    - Cú pháp:
        try {
            //Chạy vào đây đầu tiên
        } catch (error) {
            //Nếu lỗi chạy vào đây
        } finally {
            //Luôn luôn chạy vào đây và chạy sau cùng
        }
    - Các bước thực thi:
        + Bước 1: Thực hiện trong try
        + Bước 2: Nếu trong try xuất hiện lỗi thì các câu lệnh trong try không được thực thi. Và nhảy sang catch, các câu lệnh trong catch sẽ được thực thi
        + Bước 3: Cuối cùng nhảy xuống finally dù là lỗi hay không, finally là lựa chọn thêm, không bắt buộc phải thêm vào.
    - Lưu ý: Nếu dùng try catch thì nếu trong try catch gặp lỗi thì các câu lệnh bên ngoài try catch vẫn chạy bình thường. Nếu không dùng try catch mà gặp phải lỗi 
    thì các câu lệnh phía sau sẽ bị dừng
3. Làm việc với Object nâng cao
3.1 Cách thêm 1 key mới vào Object
    - Cú pháp:
        tenObject.tenKey = value;
    - Hoặc:
        tenObject["tenKey"] = value; 
3.2 Cách xoá 1 key vào Object
    - Cú pháp:
        delete tenObject.tenKey;
4. Làm việc với Array nâng cao
4.1 forEach()
    - Để duyệt qua mỗi phần tử của mảng và thực hiện một hành động nào đó
    - Có thể thay đổi trực tiếp mảng ban đầu
    - Cú pháp:
        arr.forEach(function(currentValue, index, array) {
            //Code
        });
    - Trong đó:
        + currentValue: phtu hiện tại đang được xử lý của array
        + index: chỉ số của phtu hiện tại đang được xử lý của array.
        + array: mảng hiện tại đang gọi hàm forEach()/every()/some()/find()/filter()/map()/reduce()
4.2 every()
    - Kiểm tra tất cả các phtu của một mảng phải thoả mãn một điều kiện gì đó
    - Cú pháp:
        arr.every(function(currentValue, index, array){
            //Code
        });
4.3 some()
    - Kiểm tra chỉ cần một phtu của một mảng thoả mãn một điều kiện gì đó là được
    - Cú pháp:
        arr.some(function(currentValue, index, array){
            //Code
        });
4.4 find()
    - Tìm xem trong mảng có giá trị giống với giá trị đang cần tìm không, nếu có thì trả về chính phtu của mảng đó.
    Nếu không có thì trả về underfined.
    - Chỉ tìm được 1 phtu trong mảng
    - Cú pháp:
        arr.find(function(currentValue, index, array) {
            //Code
        });
4.5 filter()
    - Giống find(), nhưng cho phép tìm được nhiều phần tử và trả về một array gồm các phtu đã tìm được
    - Cú pháp:
        arr.filter(function(currentValue, index, array){
            //Code
        });
4.6 map()
    - Hàm map() sẽ lặp qua từng phtu trong mảng. Giá trị trả về của hàm map là một mảng mới, với số lượng phần tử bằng với mảng cũ,
    nhưng giá trị của các phần tử thì được quyết định bởi lệnh return của hàm map
    - Cú pháp:
        arr.map(function(currentValue, index, array){
            //Code
        });
4.7 reduce()
    - Hàm reduce() sẽ duyệt qua từng phần tử trong mảng và tính toán các phần tử đó, sau đó trả về một giá trị cuối cùng
    - Cú pháp:
        arr.reduce(function(total, currentValue, currentIndex, array){
            //Code
        }, initialValue);
    - Trong đó:
        + total: giá trị trả lại trước đó của function, chính là giá trị của lệnh return cho mỗi lần lặp
        + initialValue: tham số không bắt buộc. Nếu được truyền vào thì initialValue sẽ được sử dụng làm giá trị ban đầu, còn không
        thì nó sẽ lấy giá trị của phần tử đầu tiên